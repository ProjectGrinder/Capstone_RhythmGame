\section{Problem Solving \& Related Work}
\label{sec:problem-solving-related-work}

\subsection{Review of Existing Knowledge}
\label{subsec:review-of-existing-knowledge}

\subsubsection*{Software Bloat Analysis}

As hardware has been improving with microprocessors since the 1980s, software engineering practices have
also evolved to match the higher performance provided by the runtime system and architecture.
However, the growth of software requirements proves to be higher in terms of functionality and size.
As the software complexity rapidly increases, the performance improvement from hardware has not been 
able to grow fast enough to satisfy the demands.
Hence, performance optimization is necessary in modern software despite the advancement of CPUs and 
memory systems.
\\\\
A study on software bloat~\cite{Software_Bloat_Analysis} claimed that the main cause of performance 
problems in software systems was not from hardware limitations, but from lack of optimization in software design.
Modern object-oriented applications often suffer from inefficient use of memory, such as memory leaks 
which accumulate unused objects and exhaust the heap space, and algorithms that are not suitable for 
large data sets.
Though multicore processors have been widely adapted to improve performance via parallelism, the root
causes of performance bottlenecks are left unsolved.
\\\\
Solving performance issues in software systems requires effort, time, and knowledge to analyze and 
pinpoint the causes of bottlenecks.
Though there are studies on bloat detection and analysis to identify the sources of inefficiencies 
in software systems, there are still challenges in the process of bloat removal.
Because the definition of bloat is subjective and varies across different applications, it is challenging
to create a universal solution for bloat removal.
Therefore, the process of removing performance bottlenecks requires careful consideration and specification 
to precisely resolve the issues without affecting the intended functionality of the software.

\subsubsection*{Latency in Video Games}

When any system has to process inputs and produce outputs, there is always a delay between the input event and the output response.
This delay is known as latency, the time taken for data to travel from the source to the destination.
A study on latency in game engines, including Unity and Unreal Engine~\cite{Gotta_Go_Fast}, measured the input-to-display latency.
The results showed both engines had small latencies of around 40 to 50 milliseconds.
\\\\
Though removing latency entirely is impossible, reducing latency is crucial in interactive media, especially ones that require continuous user inputs.
High latency can lead to poor user experience, as users may feel disconnected from the system.
There have been studies and experiments on the effects of latency on user performance in games, from simple point-and-click game to intense first-person shooter game~\cite{Playing_With_Delay}~\cite{Latency_And_Perspective}~\cite{Lower_Better}.
The results showed an identical trend that higher latency leads to worse performance, with users taking longer time to complete tasks and feeling less satisfied with the experience.
This emphasizes the importance of low latency in interactive media to ensure a smooth and responsive experience for users.

\subsubsection*{Entity-Component-System Architecture}

Entity-component-system (ECS) is a software architectural pattern mostly used in game development.
Its mechanisms are characterized by the entities, composed of components of data,
and the systems which operate upon those components.
The behaviors of these entities are modified at runtime by systems modifying, adding, or removing the components
attached to said entities.
\\\\
Implementations of ECS already exist, even in production contexts.
One of the more popular implementations is EnTT~\cite{ValtoLibraries_EnTT}, a header-only C++ library for game programming.
This library has been used to develop many game titles, the most major of which is Minecraft.
Another popular implementation is Bevy ECS~\cite{Bevy_Engine}, a data-driven game engine built in Rust.
\\\\
However, most existing ECS libraries use runtime component registration, perform type-erased iteration, or resolve
system dependencies at runtime, or some combination of the above.
While they often optimize queries via template views or code specialization, they cannot fully eliminate
runtime overhead associated with registration, lookup, or caching.
Experimental systems like Vittorio's ECST~\cite{vittorio} achieve deep compile-time specialization
but are not production-ready due to ambiguity in naming, sparse documentation, and hidden dependencies.

\subsection{Comparison with Existing Systems}
\label{subsec:comparison-with-existing-systems}

We have reviewed existing well-known free software systems that are designed for interactive media
development to understand their strengths and weaknesses in their architectures and design.

\subsubsection*{Game Engines}

When comparing current popular game engines, such as Unity~\cite{Unity_Engine} and Unreal Engine~\cite{Unreal_Engine}, 
there are some notable differences in their architecture and performance.
\\\\
Unity uses a component-based architecture, where game objects can contain various components which 
determine their behaviors.
This architecture allows for flexibility and modularity, as components can be added or removed dynamically 
from objects.
Unity also provides a data-oriented technology stack (DOTS)~\cite{Unity_DOTS} that utilizes
ECS architecture to improve performance by optimizing memory layout and enabling multithreading on 
multiple packages.
The system is built on a native C / C++ engine core, reducing runtime overhead and allowing
cross-platform compatibility.
However, the system uses C\# on .NET Framework for the scripting layer, which introduces memory management
overhead from frequent garbage collection cycles.
Additionally, Unity's architecture relies on object-oriented programming (OOP), which can lead to performance 
bottlenecks when managing large numbers of game objects due to deep inheritance hierarchies.
This, along with tight coupling between game objects and their behaviors, leads to challenges in scalability and maintainability.
\\\\
Unreal Engine also uses a similar component-based architecture, with objects composed of various components 
to define their behaviors, but the engine is built entirely in C++, allowing for high 
performance and low-level control over system resources.
The engine is also built with modular subsystems (rendering, physics, audio, etc.) that utilize multithreading 
to improve performance.
Unreal Engine 5 introduces a new framework similar to ECS called MassEntity~\cite{Unreal_MassEntity}, which aims to 
improve performance by optimizing memory layout for large-scale simulations.
Currently, in 2025, the MassEntity system is still in development and not fully integrated into the engine.
On the other hand, the engine uses a visual scripting system called Blueprints, which can introduce additional 
performance overhead.
Moreover, Unreal Engine contains advanced features such as real-time ray tracing and high-fidelity graphics, 
which can be resource-intensive and may require high-end hardware to run smoothly.
\\\\
Upon comparison, both engines have their strengths and weaknesses in terms of architecture and performance, 
which can impact their suitability for different types of projects.
Both engines utilize component-based architectures that promote modularity and flexibility.
Unity's flexibility and modularity make it a good choice for smaller projects or those requiring rapid 
developing cycles, but could suffer from performance issues in larger-scale applications.
Meanwhile, Unreal Engine's high performance and advanced features aim for high-quality
3D projects, but the system is not built to support the general media applications due to its massive 
performance costs.

\subsubsection*{Digital Content Creation Tools}

Digital Content Creation (DCC) tools, such as Blender~\cite{Blender}, are widely used in the creation 
of 3D models, animations, and visual effects.
\\\\
Blender is an open-source DCC tool built with native C/C++ core for optimized data processing and 
memory management.
The system uses dependency graphs~\cite{Blender_Dependency} to update and manage relationships of scene data
efficiently by only considering what is dependent on the modified value.
Blender also uses a specialized system called DNA~\cite{Blender_DNA} and RNA~\cite{Blender_RNA} to manage 
data structures and properties.
DNA is a low-level system that defines the data structures used in Blender to enable forward and backward 
compatibility across different versions of the software.
The system generates a binary representation for the data structures, called Structure DNA (SDNA).
Then, SDNA is embedded with the actual data, making the contents in the files self-descriptive and portable 
across other versions of the system.
On top of DNA, RNA is a higher-level system that provides an interface for accessing and manipulating 
Blender's data structures at runtime, allowing for dynamic interaction with the data.
\\\\
Blender's architecture is designed to be modular and extensible from its data-block structure, allowing for
the addition of new features from plugins and scripts.
However, the system uses Python for scripting layer and API which, while flexible and easy to use,
can introduce performance overhead due to its interpreted nature.
Additionally, Blender's DNA/RNA systems can add complexity to the data management process, which may cause 
complications for developers when improving or extending the system in the future.
Therefore, while Blender's architecture is optimized for performance and flexibility, there are still 
challenges in balancing these aspects effectively.

\subsection{Gap Analysis}
\label{subsec:gap-analysis}

Upon reviewing existing systems and related work, it is clear that each system has its own strengths depending
on the intended use cases.
However, there are still gaps and limitations that can be addressed to improve performance and flexibility.
\\\\
Game engines in the past often relied on object-oriented programming (OOP) principles, which make the system easy to 
understand due to its similar concepts to real-world objects.
However, OOP is often denounced in modern software engineering for its complexity and inefficiency in managing 
large-scale applications with numerous data structures.
While concepts like inheritance and polymorphism provide flexibility in development, they can also be overwhelmed 
when managing complex relationships between objects, leading to tight coupling and deep inheritance hierarchies.
Hence, game engines like Unity and Unreal Engine have been shifting towards data-oriented designs like ECS to improve 
performance and scalability.
\\\\
As software demands continue to surpass the current hardware capabilities, system optimization is crucial to ensure 
efficient resource utilization and performance.
A recent study on game engine efficiency~\cite{Game_Engine_Efficiency} experimented with Unity, Unreal Engine, 
Godot~\cite{Godot_Engine}, and a custom-built engine using ECS architecture and scripting system in C syntax.
When using the engines to buid a simple 2D game, the study showed that as the number of objects increased, the custom 
ECS engine outperformed every other engine in terms of CPU usage, power consumption, and memory usage.
This indicates that further optimization is still possible with efficient architecture.

\subsection{Linkage to Project}
\label{subsec:linkage-to-project}

Upon analyzing existing systems in the market, it is evident that there are still gaps and limitations 
that can be addressed to improve performance and flexibility.
We aim to create a framework that combines the strengths of existing architectures while addressing 
their weaknesses.
By utilizing the ECS architecture, we can achieve better performance and scalability compared to
traditional OOP-based designs.
We want to combine the best of both worlds \textemdash to create an ECS framework that registers and determines component types
and system dependencies at compile-time, while ensuring code flexibility and production-ready performance, complete
with rigorous documentation.
\\\\
In order to showcase the capabilities of our proposed framework, we plan to develop a game prototype that utilizes 
the system performance to its fullest potential.
We have designed a game that combines two performance-intensive genres: rhythm games and bullet hell shooters.
Rhythm games require players to interact with the game in sync with the music, demanding precise timing and 
responsiveness as much as in millisecond accuracy.
Bullet hell shooters, on the other hand, involve navigating through a screen filled with numerous projectiles, 
requiring efficient handling of a large number of entities and collision detection.
By merging these two genres, we can create a game that demonstrates our framework's performance and responsiveness.